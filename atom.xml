<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Gary Wu</title>
  
  <subtitle>运维架构师 - 从入门到放弃</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://garywu520.github.io/blog/"/>
  <updated>2019-09-19T09:44:00.383Z</updated>
  <id>https://garywu520.github.io/blog/</id>
  
  <author>
    <name>Gary Wu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis主从+sentinel哨兵-理论</title>
    <link href="https://garywu520.github.io/blog/2019/09/19/Redis%E4%B8%BB%E4%BB%8E-sentinel%E5%93%A8%E5%85%B5-%E7%90%86%E8%AE%BA/"/>
    <id>https://garywu520.github.io/blog/2019/09/19/Redis主从-sentinel哨兵-理论/</id>
    <published>2019-09-19T08:14:04.000Z</published>
    <updated>2019-09-19T09:44:00.383Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、目录"><a href="#一、目录" class="headerlink" title="一、目录"></a>一、目录</h4><ul><li><p>Redis内存回收策略</p></li><li><p>主从+哨兵模式核心知识点</p></li></ul><p>注：Redis主从+sentinel哨兵集群部署：<a href="https://garywu520.github.io/blog/2019/09/19/Redis%E4%B8%BB%E4%BB%8E-sentinel%E5%93%A8%E5%85%B5%E9%AB%98%E5%8F%AF%E7%94%A8/#more">参考</a></p><a id="more"></a><h4 id="二、关于Redis内存回收策略"><a href="#二、关于Redis内存回收策略" class="headerlink" title="二、关于Redis内存回收策略"></a>二、关于Redis内存回收策略</h4><p>Redis会因为内存不足而产生错误，也会因为回收过久而导致系统长期处于卡顿状态。当Redis的内存达到规定的最大值时，可以进行配置淘汰key, 并对key进行回收。</p><p>redis八大回收机制：</p><ul><li><p>noeviction[默认策略]</p><p>不淘汰任何键值对, 当内存满时，读操作(例如:get命令) 它将政策工作，而做写操作，它将返回错误。所以，当内存满时，redis就不能写了</p></li><li><p>volatile-lru: 采用最近最少的淘汰策略, Redis将回收那些超时的(仅仅是超时的)键值对。</p></li><li><p>allkeys-lru: 采用最近最少的淘汰策略，Redis将对所有的(不仅仅是超时的)键值对采用最近最少使用的淘汰策略</p></li><li><p>volatile-lfu: 采用最近最不常用的淘汰策略，也就是在一定时间内，被访问次数最少的(已超时)键值对将被回收。</p></li><li><p>allkeys-lfu: 采用最近最不常用的淘汰策略，Redis将对所有的键值对采用最近最不常用的淘汰策略。</p></li><li><p>volatile-random：采用随机淘汰策略删除超时的键值对。</p></li><li><p>allkeys-random：采用随机淘汰策略删除所有的键值对，这个策略不常用。</p></li><li><p>volatile-ttl：采用删除存活时间最短的键值对策略。</p></li></ul><p>注：LRU算法或者TTL算法都是不精确的算法，而是一个近似算法。</p><p>动态设置回收策略</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> config <span class="built_in">set</span> maxmemory 768mb    <span class="comment">#最大限制内存</span></span></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> config <span class="built_in">set</span> maxmemory-policy volatile-lru <span class="comment">#内存回收策略</span></span></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> config rewrite  <span class="comment">#配置写入配置文件</span></span></span><br></pre></td></tr></table></figure><h4 id="三、主从-哨兵模式核心知识点"><a href="#三、主从-哨兵模式核心知识点" class="headerlink" title="三、主从+哨兵模式核心知识点"></a>三、主从+哨兵模式核心知识点</h4><h5 id="1-关于哨兵的介绍"><a href="#1-关于哨兵的介绍" class="headerlink" title="1. 关于哨兵的介绍"></a>1. 关于哨兵的介绍</h5><p>sentinel, 中文：哨兵，哨兵是redis重要的一个组件，具有以下功能</p><ul><li><p>集群监控: 负责监控redis master和slave进程是否正常工作</p></li><li><p>消息通知: 如果某个redis实例有故障,那么哨兵负责发送消息作为报警通知给管理员</p></li><li><p>故障转移：如果master node挂掉了，master功能会自动转移到slave node上</p></li><li><p>配置中心：如果故障转移发生了，通知client客户端新的master地址</p><p> 哨兵用于实现redis集群高可用，本身也是分布式的，作为一个哨兵集群去运行，互相协同工作。</p></li><li><p>故障转移时，判断一个master node是否宕机了，需要大部分的哨兵同意才行，涉及到了分布式选举的问题。</p></li><li><p>即使部分哨兵节点挂掉了，哨兵集群还是可以正常工作的。</p></li></ul><h5 id="2-哨兵的核心知识"><a href="#2-哨兵的核心知识" class="headerlink" title="2. 哨兵的核心知识"></a>2. 哨兵的核心知识</h5><ul><li><p>哨兵至少需要3个实例来保证自己的健壮性。</p></li><li><p>哨兵+redis主从的部署架构，是不保证数据零丢失的，只能保证redis集群的高可用性</p><p>哨兵sentinel主备切换导致的数据丢失问题</p></li></ul><h5 id="3-两种情况导致的数据丢失："><a href="#3-两种情况导致的数据丢失：" class="headerlink" title="3. 两种情况导致的数据丢失："></a>3. 两种情况导致的数据丢失：</h5><ul><li><ol><li>异步复制过程中导致的数据丢失</li></ol><p>因为master –&gt; slave的同步是异步的，所以有可能有部分数据还没复制到slave，master就down机了，此时这部分数据就丢失了。</p></li><li><ol><li>脑裂导致的数据丢失</li></ol><p>脑裂，也就是说某个master所在的机器突然脱离了网络，跟其他slave不能正常通信，但是实际上Master还运行着。此时哨兵会认为master已经宕机了，然后开始重新选举，将其他slave切换成了master。这个时候集群里出现了2个master。</p><p>如果某个slave被哨兵选举切换成了master，但是可能client还没来得及切换到新master，还会继续向旧master写数据。因此，旧master再次恢复的时候，会被作为一个slave挂到新的master上去，而自己的数据会被清空，重新从新的master复制数据。而新的master并没有后来client写入的数据，因此，这部分数据就丢失了</p></li></ul><p>数据丢失问题解决方案：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">control data loss</span></span><br><span class="line">min-slaves-to-write 1</span><br><span class="line">min-slaves-max-lag 10</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">表示：至少有1个slave的数据复制和同步延迟不能超过10秒；如果所有的slave数据复制和延迟都超过了10秒，那么这个时候，master就不会再接受任何请求了。</span></span><br></pre></td></tr></table></figure><ul><li><p>减少异步复制数据丢失</p><p>min-slaves-max-lag这个参数，一旦slave复制数据和ack延时太长，就认为可能master宕机后损失的数据太多了，那么就拒绝写请求。从而把数据丢失降低到可控范围</p></li><li><p>减少脑裂的数据丢失</p><p>如果一个master出现了脑裂，跟其他slave断开了连接，如果不能给指定数量的slave发送数据，那么如果slave超过10秒没有给自己发送ack消息，则直接拒绝客户端的写请求。因此在脑裂环境下，最多就丢失10秒的数据。</p></li></ul><h5 id="3-关于sdown和odown转换机制"><a href="#3-关于sdown和odown转换机制" class="headerlink" title="3. 关于sdown和odown转换机制"></a>3. 关于sdown和odown转换机制</h5><p>哨兵如何去判断master是否宕机？</p><ul><li>sdown是主观宕机，就一个哨兵如果自己觉得master宕机了，那么就是主观宕机</li><li>odown是客观宕机，如果quorum数量的哨兵都认为一个master宕机了，那么就是客观宕机。</li></ul><p>sdown达成条件很简单，如果一个哨兵ping一个master, 超过了is-master-down-after-milliseconds指定的毫秒数之后，就主观认为master宕机了；</p><p>如果一个哨兵在指定的时间内，收到了quorum数量的其他哨兵也认为那个master是sdown的状态，那么就认为是odown</p><h5 id="4-哨兵集群的自动发现机制"><a href="#4-哨兵集群的自动发现机制" class="headerlink" title="4. 哨兵集群的自动发现机制"></a>4. 哨兵集群的自动发现机制</h5><p>哨兵互相之间的发现，是通过 redis 的 <code>pub/sub</code> 系统实现的，每个哨兵都会往 <code>__sentinel__:hello</code> 这个 channel 里发送一个消息，这时候所有其他哨兵都可以消费到这个消息，并感知到其他的哨兵的存在。</p><p>每隔两秒钟，每个哨兵都会往自己监控的某个 master+slaves 对应的 <code>__sentinel__:hello</code> channel 里<strong>发送一个消息</strong>，内容是自己的 host、ip 和 runid 还有对这个 master 的监控配置。</p><p>每个哨兵也会去<strong>监听</strong>自己监控的每个 master+slaves 对应的 <code>__sentinel__:hello</code> channel，然后去感知到同样在监听这个 master+slaves 的其他哨兵的存在。</p><p>每个哨兵还会跟其他哨兵交换对 <code>master</code> 的监控配置，互相进行监控配置的同步。</p><h5 id="5-Slave配置的自动纠正"><a href="#5-Slave配置的自动纠正" class="headerlink" title="5. Slave配置的自动纠正"></a>5. Slave配置的自动纠正</h5><p>哨兵会负责自动纠正 slave 的一些配置，比如 slave 如果要成为潜在的 master 候选人，哨兵会确保 slave 复制现有 master 的数据；如果 slave 连接到了一个错误的 master 上，比如故障转移之后，那么哨兵会确保它们连接到正确的 master 上。</p><h5 id="6-Slave-—-gt-Master选举算法"><a href="#6-Slave-—-gt-Master选举算法" class="headerlink" title="6. Slave —&gt; Master选举算法"></a>6. Slave —&gt; Master选举算法</h5><p>如果一个 master 被认为 odown 了，而且 majority 数量的哨兵都允许主备切换，那么某个哨兵就会执行主备切换操作，此时首先要选举一个 slave 来，会考虑 slave 的一些信息：</p><ul><li>跟 master 断开连接的时长</li><li>slave 优先级</li><li>复制 offset</li><li>run id</li></ul><p>如果一个 slave 跟 master 断开连接的时间已经超过了 <code>down-after-milliseconds</code> 的 10 倍，外加 master 宕机的时长，那么 slave 就被认为不适合选举为 master。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(down-after-milliseconds * 10) + milliseconds_since_master_is_in_SDOWN_state</span><br></pre></td></tr></table></figure><p>接下来会对 slave 进行排序：</p><ul><li>按照 slave 优先级进行排序，slave priority 越低，优先级就越高。</li><li>如果 slave priority 相同，那么看 replica offset，哪个 slave 复制了越多的数据，offset 越靠后，优先级就越高。</li><li>如果上面两个条件都相同，那么选择一个 run id 比较小的那个 slave。</li></ul><h5 id="7-quorum和majority"><a href="#7-quorum和majority" class="headerlink" title="7. quorum和majority"></a>7. quorum和majority</h5><p>每次一个哨兵要做主备切换，首先需要 quorum 数量的哨兵认为 odown，然后选举出一个哨兵来做切换，这个哨兵还需要得到 majority 哨兵的授权，才能正式执行切换。</p><p>如果 quorum &lt; majority，比如 5 个哨兵，majority 就是 3，quorum 设置为 2，那么就 3 个哨兵授权就可以执行切换。</p><p>但是如果 quorum &gt;= majority，那么必须 quorum 数量的哨兵都授权，比如 5 个哨兵，quorum 是 5，那么必须 5 个哨兵都同意授权，才能执行切换。</p><h5 id="8-configuration-epoch"><a href="#8-configuration-epoch" class="headerlink" title="8. configuration epoch"></a>8. configuration epoch</h5><p>哨兵会对一套 redis master+slaves 进行监控，有相应的监控的配置。</p><p>执行切换的那个哨兵，会从要切换到的新 master（salve-&gt;master）那里得到一个 configuration epoch，这就是一个 version 号，每次切换的 version 号都必须是唯一的。</p><p>如果第一个选举出的哨兵切换失败了，那么其他哨兵，会等待 failover-timeout 时间，然后接替继续执行切换，此时会重新获取一个新的 configuration epoch，作为新的 version 号。</p><h5 id="9-configuration传播"><a href="#9-configuration传播" class="headerlink" title="9. configuration传播"></a>9. configuration传播</h5><p>哨兵完成切换之后，会在自己本地更新生成最新的 master 配置，然后同步给其他的哨兵，就是通过之前说的 <code>pub/sub</code> 消息机制。</p><p>这里之前的 version 号就很重要了，因为各种消息都是通过一个 channel 去发布和监听的，所以一个哨兵完成一次新的切换之后，新的 master 配置是跟着新的 version 号的。其他的哨兵都是根据版本号的大小来更新自己的 master 配置的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一、目录&quot;&gt;&lt;a href=&quot;#一、目录&quot; class=&quot;headerlink&quot; title=&quot;一、目录&quot;&gt;&lt;/a&gt;一、目录&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Redis内存回收策略&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;主从+哨兵模式核心知识点&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注：Redis主从+sentinel哨兵集群部署：&lt;a href=&quot;https://garywu520.github.io/blog/2019/09/19/Redis%E4%B8%BB%E4%BB%8E-sentinel%E5%93%A8%E5%85%B5%E9%AB%98%E5%8F%AF%E7%94%A8/#more&quot;&gt;参考&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="高级运维" scheme="https://garywu520.github.io/blog/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="redis" scheme="https://garywu520.github.io/blog/tags/redis/"/>
    
      <category term="sentinel" scheme="https://garywu520.github.io/blog/tags/sentinel/"/>
    
  </entry>
  
  <entry>
    <title>Redis主从+sentinel哨兵高可用</title>
    <link href="https://garywu520.github.io/blog/2019/09/19/Redis%E4%B8%BB%E4%BB%8E-sentinel%E5%93%A8%E5%85%B5%E9%AB%98%E5%8F%AF%E7%94%A8/"/>
    <id>https://garywu520.github.io/blog/2019/09/19/Redis主从-sentinel哨兵高可用/</id>
    <published>2019-09-19T07:50:02.000Z</published>
    <updated>2019-09-19T10:16:02.604Z</updated>
    
    <content type="html"><![CDATA[<h5 id="一、环境"><a href="#一、环境" class="headerlink" title="一、环境"></a>一、环境</h5><ul><li><p>基本环境</p><table><thead><tr><th align="center">软件</th><th align="center">版本</th></tr></thead><tbody><tr><td align="center">Redis</td><td align="center">5.0.5</td></tr><tr><td align="center">OS</td><td align="center">CentOS7</td></tr></tbody></table></li><li><p>集群环境</p><table><thead><tr><th align="center">角色</th><th align="center">IP</th><th align="center">端口</th></tr></thead><tbody><tr><td align="center">Master主节点1</td><td align="center">192.168.1.198</td><td align="center">6379</td></tr><tr><td align="center">sentinel-哨兵1</td><td align="center">192.168.1.198</td><td align="center">16379</td></tr><tr><td align="center">Slave从节点2</td><td align="center">192.168.1.121</td><td align="center">6379</td></tr><tr><td align="center">sentinel-哨兵2</td><td align="center">192.168.1.121</td><td align="center">16379</td></tr><tr><td align="center">Slave从节点3</td><td align="center">192.168.1.145</td><td align="center">6379</td></tr><tr><td align="center">sentinel-哨兵3</td><td align="center">192.168.1.145</td><td align="center">16379</td></tr></tbody></table><p>注：为了哨兵集群的健壮性，哨兵的节点数量建议是≥3的奇数。</p><p>​      哨兵 + redis 主从的部署架构，是<strong>不保证数据零丢失</strong>的，只能保证 redis 集群的高可用性。</p><a id="more"></a>     </li></ul><h5 id="二、安装Redis"><a href="#二、安装Redis" class="headerlink" title="二、安装Redis"></a>二、安装Redis</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">yum install -y gcc g++ gcc-c++ make tcl</span><br><span class="line">wget http://download.redis.io/releases/redis-5.0.5.tar.gz</span><br><span class="line">tar -zxvf redis-5.0.5.tar.gz</span><br><span class="line">cd redis-5.0.5</span><br><span class="line">make</span><br><span class="line">make PREFIX=/usr/local/redis install</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /usr/local/redis/etc</span><br><span class="line">cp /root/redis-5.0.5/redis.conf /usr/local/redis/etc/</span><br><span class="line">cp /root/redis-5.0.5/sentinel.conf /usr/local/redis/etc/</span><br><span class="line">mkdir -p /var/log/redis  #创建日志目录</span><br><span class="line">mkdir -p /usr/local/redis/data  #创建数据存放目录</span><br></pre></td></tr></table></figure><h5 id="三、配置Redis主从复制"><a href="#三、配置Redis主从复制" class="headerlink" title="三、配置Redis主从复制"></a>三、配置Redis主从复制</h5><p>全节点优化</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">echo 2048 &gt; /proc/sys/net/core/somaxconn</span><br><span class="line"><span class="meta">#</span><span class="bash">在/etc/sysctl.conf中添加如下</span></span><br><span class="line">net.core.somaxconn = 2048</span><br><span class="line">vm.overcommit_memory = 1</span><br><span class="line"></span><br><span class="line">sysctl -p</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled</span><br><span class="line">echo "echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled" &gt;&gt;/etc/rc.d/rc.local</span><br></pre></td></tr></table></figure><h6 id="1-Master主节点1-哨兵"><a href="#1-Master主节点1-哨兵" class="headerlink" title="1.Master主节点1 + 哨兵"></a>1.Master主节点1 + 哨兵</h6><p>配置主redis - cat /usr/local/redis/etc/redis.conf</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">port 6379</span><br><span class="line">daemonize no</span><br><span class="line">protected-mode no</span><br><span class="line">pidfile /var/run/redis_6379.pid</span><br><span class="line">tcp-backlog 511</span><br><span class="line">bind 192.168.1.198 127.0.0.1</span><br><span class="line">timeout 0</span><br><span class="line">tcp-keepalive 300</span><br><span class="line">loglevel notice</span><br><span class="line">logfile "/var/log/redis/redis_6379.log"</span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line">dir /usr/local/redis/data</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line">maxclients 10000</span><br><span class="line">maxmemory 768mb</span><br><span class="line">appendonly no </span><br><span class="line">requirepass test123</span><br></pre></td></tr></table></figure><p>redis supervisor</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/supervisord.d/redis.conf </span><br><span class="line">[program:redis]</span><br><span class="line">directory=/usr/local/redis</span><br><span class="line">command=/usr/local/redis/bin/redis-server /usr/local/redis/etc/redis.conf</span><br><span class="line">stdout_logfile=/var/log/redis/redis_6379.log</span><br><span class="line">autostart=true</span><br><span class="line">autorestart=true</span><br><span class="line">startsecs=5</span><br><span class="line">priority=1</span><br><span class="line">stopasgroup=true</span><br><span class="line">killasgroup=true</span><br></pre></td></tr></table></figure><p>配置sentinel集群 - cat /usr/local/redis/etc/sentinel.conf</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">bind 192.168.1.198</span><br><span class="line">protected-mode no</span><br><span class="line">daemonize no</span><br><span class="line">port 16379</span><br><span class="line">logfile "/var/log/redis/redis-sentinel.log"</span><br><span class="line">dir /usr/local/redis/data</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">表示配置sentinel去监视名为redis_master的主服务器，IP为192.168.1.198，端口是6379；最后一个数字表示只要有2个sentinel同意[共3个sentinel]就可以启动自动故障迁移。</span></span><br><span class="line">sentinel monitor redis_master 192.168.1.198 6379 2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">表示如果10s内redis_master没PING响应或者返回一个错误，sentinel就把服务器标记为主观下线[简称: SDOWN]</span></span><br><span class="line">sentinel down-after-milliseconds redis_master 10000</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">在执行故障转移时， 最多可以有多少个从slave服务器同时对新的主服务器进行同步， 这个数字越小， 完成故障转移所需的时间就越长。</span></span><br><span class="line">sentinel parallel-syncs redis_master 1 </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">sentinel哨兵连接主节点密码[需要与master密码一致]</span></span><br><span class="line">sentinel auth-pass redis_master test123</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#表示如果15秒后,mysater仍没活过来，则启动failover，从剩下的slave中选一个升级为master</span></span></span><br><span class="line">sentinel failover-timeout redis_master 15000</span><br></pre></td></tr></table></figure><p>redis-sentinel supervisor</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[program:redis-sentinel]</span><br><span class="line">directory=/usr/local/redis</span><br><span class="line">command=/usr/local/redis/bin/redis-sentinel /usr/local/redis/etc/sentinel.conf</span><br><span class="line">stdout_logfile=/var/log/redis/redis-sentinel.log</span><br><span class="line">autostart=true</span><br><span class="line">autorestart=true</span><br><span class="line">startsecs=5</span><br><span class="line">priority=1</span><br><span class="line">stopasgroup=true</span><br><span class="line">killasgroup=true</span><br></pre></td></tr></table></figure><h6 id="2-部署Redis从节点2-哨兵"><a href="#2-部署Redis从节点2-哨兵" class="headerlink" title="2.部署Redis从节点2 + 哨兵"></a><strong>2.部署Redis从节点2</strong> + 哨兵</h6><p>配置从redis - cat /usr/local/redis/etc/redis.conf</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">port 6379</span><br><span class="line">daemonize no</span><br><span class="line">protected-mode no</span><br><span class="line">pidfile /var/run/redis_6379.pid</span><br><span class="line">tcp-backlog 511</span><br><span class="line">bind 192.168.1.121 127.0.0.1</span><br><span class="line">timeout 0</span><br><span class="line">tcp-keepalive 300</span><br><span class="line">loglevel notice</span><br><span class="line">logfile "/var/log/redis/redis_6379.log"</span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line">slaveof 192.168.1.198 6379</span><br><span class="line">dir /usr/local/redis/data</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line">maxclients 10000</span><br><span class="line">maxmemory 768mb</span><br><span class="line">appendonly no </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">从库添加master密码</span></span><br><span class="line">masterauth test123  </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">从库自身认证密码</span></span><br><span class="line">requirepass test123</span><br></pre></td></tr></table></figure><p>supervisor</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[program:redis]</span><br><span class="line">directory=/usr/local/redis</span><br><span class="line">command=/usr/local/redis/bin/redis-server /usr/local/redis/etc/redis.conf</span><br><span class="line">stdout_logfile=/var/log/redis/redis_6379.log</span><br><span class="line">autostart=true</span><br><span class="line">autorestart=true</span><br><span class="line">startsecs=5</span><br><span class="line">priority=1</span><br><span class="line">stopasgroup=true</span><br><span class="line">killasgroup=true</span><br></pre></td></tr></table></figure><p>配置sentinel集群 - cat /usr/local/redis/etc/sentinel.conf 只需修改Bind地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bind 192.168.1.121</span><br><span class="line">protected-mode no</span><br><span class="line">daemonize no</span><br><span class="line">port 16379</span><br><span class="line">logfile "/var/log/redis/redis-sentinel.log"</span><br><span class="line">dir /usr/local/redis/data</span><br><span class="line"></span><br><span class="line">sentinel monitor redis_master 192.168.1.198 6379 2</span><br><span class="line">sentinel down-after-milliseconds redis_master 10000</span><br><span class="line">sentinel parallel-syncs redis_master 1 </span><br><span class="line">sentinel auth-pass redis_master test123</span><br><span class="line">sentinel failover-timeout redis_master 15000</span><br></pre></td></tr></table></figure><p>redis-sentinel supervisor</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[program:redis-sentinel]</span><br><span class="line">directory=/usr/local/redis</span><br><span class="line">command=/usr/local/redis/bin/redis-sentinel /usr/local/redis/etc/sentinel.conf</span><br><span class="line">stdout_logfile=/var/log/redis/redis-sentinel.log</span><br><span class="line">autostart=true</span><br><span class="line">autorestart=true</span><br><span class="line">startsecs=5</span><br><span class="line">priority=1</span><br><span class="line">stopasgroup=true</span><br><span class="line">killasgroup=true</span><br></pre></td></tr></table></figure><h6 id="3-部署Redis从节点2-哨兵"><a href="#3-部署Redis从节点2-哨兵" class="headerlink" title="3.部署Redis从节点2 + 哨兵"></a>3.部署Redis从节点2 + 哨兵</h6><p>参考步骤2，注意修改bind地址</p><h4 id="四、验证"><a href="#四、验证" class="headerlink" title="四、验证"></a>四、验证</h4><h5 id="1-主从验证"><a href="#1-主从验证" class="headerlink" title="1. 主从验证"></a>1. 主从验证</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash">  info Replication      <span class="comment">#查看节点状态</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:2</span><br><span class="line">min_slaves_good_slaves:2</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis&gt;  info Replication      #查看节点状态</span><br><span class="line"># Replication</span><br><span class="line">role:slave</span><br><span class="line">master_host:192.168.1.198</span><br><span class="line">master_port:6379</span><br><span class="line">master_link_status:up</span><br></pre></td></tr></table></figure><h5 id="2-哨兵-高可用验证"><a href="#2-哨兵-高可用验证" class="headerlink" title="2.  哨兵 高可用验证"></a>2.  哨兵 高可用验证</h5><ul><li><p>首先stop 198的master节点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop redis</span><br></pre></td></tr></table></figure></li><li><p>登录121和145 redis，查看info信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">查看谁被选举成了新的Master，然后登录新Master节点</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">往新master节点插入新数据</span></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> <span class="built_in">set</span> color1 red</span></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> <span class="built_in">set</span> color2 green</span></span><br></pre></td></tr></table></figure></li><li><p>重启198的master节点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">观察节点是否已经变更为slave, 并且尝试获取 color1和color2的值</span><br><span class="line"></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> get color1</span></span><br><span class="line">"red"</span><br><span class="line"></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> get color2</span></span><br><span class="line">"green"</span><br></pre></td></tr></table></figure></li><li><p>杀掉当前的master，观察是否重新进行了master选举</p></li></ul><h5 id="3-主库key过期，key依旧存在于主库–测试"><a href="#3-主库key过期，key依旧存在于主库–测试" class="headerlink" title="3. 主库key过期，key依旧存在于主库–测试"></a>3. 主库key过期，key依旧存在于主库–测试</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">主库创建测试key，并设置生效时间。当过期后，立即在从库get key测试</span></span><br><span class="line">192.168.1.198:6379&gt; set old 30</span><br><span class="line">OK</span><br><span class="line">192.168.1.198:6379&gt; get old</span><br><span class="line">"30"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">设置key 60秒过期</span></span><br><span class="line">192.168.1.198:6379&gt; EXPIRE old "60"   </span><br><span class="line">(integer) 1</span><br><span class="line">192.168.1.198:6379&gt; ttl old</span><br><span class="line">(integer) 56</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">此时，key已过期</span></span><br><span class="line">192.168.1.198:6379&gt; ttl old</span><br><span class="line">(integer) -2</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">从库获取key情况</span></span><br><span class="line">192.168.1.121:6379&gt; get old</span><br><span class="line">(nil)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">可以看到主库删除key，从库立即同步key, 不存在从库仍然可以读到过期key的情况</span></span><br></pre></td></tr></table></figure><h5 id="4-测试从库是否为只读"><a href="#4-测试从库是否为只读" class="headerlink" title="4. 测试从库是否为只读"></a>4. 测试从库是否为只读</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">192.168.1.145:6379&gt; set old 30</span><br><span class="line">(error) READONLY You can't write against a read only replica.</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">从库不支持写</span></span><br></pre></td></tr></table></figure><h5 id="5-redis压力测试"><a href="#5-redis压力测试" class="headerlink" title="5. redis压力测试"></a>5. redis压力测试</h5><p>redis自带了压测工具redis-benchmark，用法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">模拟一下10w次请求；-t参数表示只测试get,<span class="built_in">set</span>,lush,lpop操作的性能</span></span><br><span class="line">redis-benchmark -h 127.0.0.1 -p 6379 -t get,set,lush,lpop -c 50 -n 100000</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">模拟一下近百万key，-r参数是random的意思，后面跟的一个正整数M的含义是：0 ~ M之间的一个随机数。所以不是写100就是100</span></span><br><span class="line">redis-benchmark -n 1000000 -r1000000 -q</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> -c参数模拟N个用户并发</span></span><br><span class="line">redis-benchmark -c 10000 -n 1000000 -r 1000000 -q</span><br><span class="line"></span><br><span class="line">注：百万级并发压力测试，请提前配置ulimit用户文件打开数,否则会出现错误</span><br></pre></td></tr></table></figure><p>====== SET ======<br>  50000 requests completed in 0.69 seconds<br>  50 parallel clients<br>  3 bytes payload<br>  keep alive: 1</p><p>98.66% &lt;= 1 milliseconds<br>99.82% &lt;= 2 milliseconds<br>99.85% &lt;= 3 milliseconds<br>99.91% &lt;= 4 milliseconds<br>100.00% &lt;= 4 milliseconds<br>72886.30 requests per second</p><p>测试结果分析：</p><ul><li><p>上面执行了5万次的get操作，在0.69秒完成，每个数据量是3个字节</p></li><li><p>98.66%的命令在1毫秒内完成，99.85%的命令在3毫秒内完成</p></li><li><p>redis可以处理72886.30次GET请求。</p></li></ul><h4 id="五、优化"><a href="#五、优化" class="headerlink" title="五、优化"></a>五、优化</h4><h5 id="1-在所有节点-内存回收机制优化"><a href="#1-在所有节点-内存回收机制优化" class="headerlink" title="1. [在所有节点] - 内存回收机制优化"></a>1. [在所有节点] - 内存回收机制优化</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> config <span class="built_in">set</span> maxmemory-policy volatile-lru</span></span><br><span class="line">"OK"</span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> config rewrite</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">此内存回收策略是 最近使用最少的淘汰策略，Redis将回收清理那些超时的(仅仅是超时的)键值对。</span></span><br></pre></td></tr></table></figure><p>具体参考：<a href="https://www.jianshu.com/p/677930ffbff0" target="_blank" rel="noopener">https://www.jianshu.com/p/677930ffbff0</a></p><h5 id="2-哨兵sentinel主备切换导致的数据丢失问题"><a href="#2-哨兵sentinel主备切换导致的数据丢失问题" class="headerlink" title="2. 哨兵sentinel主备切换导致的数据丢失问题"></a>2. 哨兵sentinel主备切换导致的数据丢失问题</h5><p>两种情况导致的数据丢失：</p><ul><li><ol><li>异步复制过程中导致的数据丢失</li></ol><p>因为master –&gt; slave的同步是异步的，所以有可能有部分数据还没复制到slave，master就down机了，此时这部分数据就丢失了。</p></li></ul><ul><li><ol start="2"><li>脑裂导致的数据丢失</li></ol><p>脑裂，也就是说某个master所在的机器突然脱离了网络，跟其他slave不能正常通信，但是实际上Master还运行着。此时哨兵会认为master已经宕机了，然后开始重新选举，将其他slave切换成了master。这个时候集群里出现了2个master。</p><p>如果某个slave被哨兵选举切换成了master，但是可能client还没来得及切换到新master，还会继续向旧master写数据。因此，旧master再次恢复的时候，会被作为一个slave挂到新的master上去，而自己的数据会被清空，重新从新的master复制数据。而新的master并没有后来client写入的数据，因此，这部分数据就丢失了</p></li></ul><p>[所有节点]-数据丢失问题解决方案：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">control data loss</span></span><br><span class="line">min-slaves-to-write 1</span><br><span class="line">min-slaves-max-lag 10</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">表示：至少有1个slave的数据复制和同步延迟不能超过10秒；如果所有的slave数据复制和延迟都超过了10秒，那么这个时候，master就不会再接受任何请求了。</span></span><br></pre></td></tr></table></figure><ul><li><p>减少异步复制数据丢失</p><p>min-slaves-max-lag这个参数，一旦slave复制数据和ack延时太长，就认为可能master宕机后损失的数据太多了，那么就拒绝写请求。从而把数据丢失降低到可控范围</p></li><li><p>减少脑裂的数据丢失</p><p>如果一个master出现了脑裂，跟其他slave断开了连接，如果不能给指定数量的slave发送数据，那么如果slave超过10秒没有给自己发送ack消息，则直接拒绝客户端的写请求。因此在脑裂环境下，最多就丢失10秒的数据。</p></li></ul><p>理论参考：<a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/redis-sentinel.md" target="_blank" rel="noopener">Redis 哨兵集群实现高可用</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;一、环境&quot;&gt;&lt;a href=&quot;#一、环境&quot; class=&quot;headerlink&quot; title=&quot;一、环境&quot;&gt;&lt;/a&gt;一、环境&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;基本环境&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;软件&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;版本&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;Redis&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;5.0.5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;OS&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;CentOS7&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;集群环境&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;角色&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;IP&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;端口&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;Master主节点1&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;192.168.1.198&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;6379&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;sentinel-哨兵1&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;192.168.1.198&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;16379&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;Slave从节点2&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;192.168.1.121&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;6379&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;sentinel-哨兵2&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;192.168.1.121&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;16379&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;Slave从节点3&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;192.168.1.145&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;6379&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;sentinel-哨兵3&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;192.168.1.145&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;16379&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;注：为了哨兵集群的健壮性，哨兵的节点数量建议是≥3的奇数。&lt;/p&gt;
&lt;p&gt;​      哨兵 + redis 主从的部署架构，是&lt;strong&gt;不保证数据零丢失&lt;/strong&gt;的，只能保证 redis 集群的高可用性。&lt;/p&gt;
    
    </summary>
    
    
      <category term="高级运维" scheme="https://garywu520.github.io/blog/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="redis" scheme="https://garywu520.github.io/blog/tags/redis/"/>
    
      <category term="sentinel" scheme="https://garywu520.github.io/blog/tags/sentinel/"/>
    
      <category term="redis主从" scheme="https://garywu520.github.io/blog/tags/redis%E4%B8%BB%E4%BB%8E/"/>
    
  </entry>
  
  <entry>
    <title>redis key过期时间</title>
    <link href="https://garywu520.github.io/blog/2019/09/17/redis-key%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4/"/>
    <id>https://garywu520.github.io/blog/2019/09/17/redis-key过期时间/</id>
    <published>2019-09-17T06:50:44.000Z</published>
    <updated>2019-09-17T07:19:05.391Z</updated>
    
    <content type="html"><![CDATA[<p>有时候我们并不希望redis的key一直存在。例如缓存，验证码等数据，我们希望它们能在一定时间内自动的被销毁。redis提供了一些命令，能够让我们对key设置过期时间，并且让key过期之后被自动删除。</p><h5 id="一、设置-更新Key过期时间"><a href="#一、设置-更新Key过期时间" class="headerlink" title="一、设置/更新Key过期时间"></a>一、设置/更新Key过期时间</h5><ul><li><p>秒级</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> EXPIRE keyname <span class="string">"seconds"</span></span></span><br><span class="line"></span><br><span class="line">接口描述：设置一个key在当前时间"seconds"(秒)之后过期。返回1代表设置成功，返回0代表key不存在或者无法设置过期时间。</span><br></pre></td></tr></table></figure></li><li><p>毫秒级</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> PEXPIRE keyname <span class="string">"milliseconds"</span></span></span><br><span class="line"></span><br><span class="line">接口描述：设置一个key在当前时间"milliseconds"(毫秒)之后过期。返回1代表设置成功，返回0代表key不存在或者无法设置过期时间。</span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><h5 id="二、获取Key过期时间"><a href="#二、获取Key过期时间" class="headerlink" title="二、获取Key过期时间"></a>二、获取Key过期时间</h5><ul><li><p>秒级</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> TTL keyname</span></span><br><span class="line"></span><br><span class="line">接口描述：获取key的过期时间。如果key存在过期时间，返回剩余生存时间(秒)；</span><br><span class="line">如果key是永久的，返回-1；如果key不存在或者已过期，返回-2。</span><br></pre></td></tr></table></figure></li><li><p>毫秒级</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> PTTL keyname</span></span><br><span class="line"></span><br><span class="line">接口描述：获取key的过期时间。如果key存在过期时间，返回剩余生存时间(毫秒)；</span><br><span class="line">如果key是永久的，返回-1；如果key不存在或者已过期，返回-2。</span><br></pre></td></tr></table></figure></li></ul><h5 id="三、移除Key的过期时间"><a href="#三、移除Key的过期时间" class="headerlink" title="三、移除Key的过期时间"></a>三、移除Key的过期时间</h5><ul><li><p>移除key的过期时间</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> PERSIST key</span></span><br><span class="line"></span><br><span class="line">移除key的过期时间，将其转换为永久状态。如果返回1，代表转换成功。如果返回0，代表key不存在或者之前就已经是永久状态。</span><br></pre></td></tr></table></figure></li></ul><h5 id="四、将Key的值设为value，并将key的生存时间设置为seconds秒"><a href="#四、将Key的值设为value，并将key的生存时间设置为seconds秒" class="headerlink" title="四、将Key的值设为value，并将key的生存时间设置为seconds秒"></a>四、将Key的值设为value，并将key的生存时间设置为seconds秒</h5><ul><li><p>将Key的值设为value，并将key的生存时间设置为seconds秒</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> SETEX keyname &lt;过期时间&gt; &lt;value&gt;</span></span><br><span class="line"></span><br><span class="line">将键 key 的值设置为 value ， 并将键 key 的生存时间设置为 seconds 秒钟。</span><br><span class="line">如果键 key 已经存在， 那么 SETEX 命令将覆盖已有的值。</span><br></pre></td></tr></table></figure><p>等同于如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> SET key value</span></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> EXPIRE key seconds</span></span><br></pre></td></tr></table></figure></li><li><p>SETEX示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> SETEX cache_user_id 60 10086</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> GET cache_user_id   <span class="comment">#值</span></span></span><br><span class="line">"10086"</span><br><span class="line"></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> TTL cache_user_id   <span class="comment">#剩余生存时间</span></span></span><br><span class="line">(integer) 49</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有时候我们并不希望redis的key一直存在。例如缓存，验证码等数据，我们希望它们能在一定时间内自动的被销毁。redis提供了一些命令，能够让我们对key设置过期时间，并且让key过期之后被自动删除。&lt;/p&gt;
&lt;h5 id=&quot;一、设置-更新Key过期时间&quot;&gt;&lt;a href=&quot;#一、设置-更新Key过期时间&quot; class=&quot;headerlink&quot; title=&quot;一、设置/更新Key过期时间&quot;&gt;&lt;/a&gt;一、设置/更新Key过期时间&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;秒级&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;redis&amp;gt;&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; EXPIRE keyname &lt;span class=&quot;string&quot;&gt;&quot;seconds&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;接口描述：设置一个key在当前时间&quot;seconds&quot;(秒)之后过期。返回1代表设置成功，返回0代表key不存在或者无法设置过期时间。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;毫秒级&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;redis&amp;gt;&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; PEXPIRE keyname &lt;span class=&quot;string&quot;&gt;&quot;milliseconds&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;接口描述：设置一个key在当前时间&quot;milliseconds&quot;(毫秒)之后过期。返回1代表设置成功，返回0代表key不存在或者无法设置过期时间。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="高级运维" scheme="https://garywu520.github.io/blog/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="redis" scheme="https://garywu520.github.io/blog/tags/redis/"/>
    
      <category term="expire" scheme="https://garywu520.github.io/blog/tags/expire/"/>
    
      <category term="过期时间" scheme="https://garywu520.github.io/blog/tags/%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4/"/>
    
  </entry>
  
  <entry>
    <title>redis 参数动态配置</title>
    <link href="https://garywu520.github.io/blog/2019/09/16/redis-%E5%8F%82%E6%95%B0%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE/"/>
    <id>https://garywu520.github.io/blog/2019/09/16/redis-参数动态配置/</id>
    <published>2019-09-16T06:51:33.000Z</published>
    <updated>2019-09-16T06:53:11.081Z</updated>
    
    <content type="html"><![CDATA[<p>redis提供了CONFIG SET 动态配置命令，部分参数支持配置热修改而无需重启redis服务。</p><h5 id="1-redis动态修改配置"><a href="#1-redis动态修改配置" class="headerlink" title="1. redis动态修改配置"></a>1. redis动态修改配置</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 列出所有支持动态配置的参数</span><br><span class="line">127.0.0.1:6379&gt; config get *</span><br><span class="line">  1) &quot;dbfilename&quot;</span><br><span class="line">  2) &quot;dump.rdb&quot;</span><br><span class="line">     ......</span><br><span class="line">     ......</span><br><span class="line">213) &quot;bind&quot;</span><br><span class="line">214) &quot;127.0.0.1&quot;</span><br></pre></td></tr></table></figure><a id="more"></a><p>使用CONFIG SET 动态配置示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config get appendonly   #查看当前设置</span><br><span class="line">1) &quot;appendonly&quot;</span><br><span class="line">2) &quot;no&quot;</span><br><span class="line">127.0.0.1:6379&gt; </span><br><span class="line">127.0.0.1:6379&gt; config set appendonly yes  #修改设置(立刻生效)</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; config get appendonly   #查看当前设置</span><br><span class="line">1) &quot;appendonly&quot;</span><br><span class="line">2) &quot;yes&quot;</span><br><span class="line">127.0.0.1:6379&gt; config rewrite  #保存到配置文件</span><br><span class="line">ok</span><br></pre></td></tr></table></figure><p>注：如果 执行config rewrite命令出现ERR CONFIG REWRITE failed: Permission denied错误，则说明redis启动的时候没有指定redis.conf文件</p><h5 id="2-其他：动态更新监听地址-bind参数配置"><a href="#2-其他：动态更新监听地址-bind参数配置" class="headerlink" title="2. 其他：动态更新监听地址-bind参数配置"></a>2. 其他：动态更新监听地址-bind参数配置</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config set bind &quot;127.0.0.1 11.12.13.14&quot;</span><br><span class="line">(error) ERR Unsupported CONFIG parameter: bind</span><br></pre></td></tr></table></figure><p>出现上面的错误 是因为并不是所有配置都可以在线修改，比如pidfile，port, 以及bind 这些参数是不允许修改的</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;redis提供了CONFIG SET 动态配置命令，部分参数支持配置热修改而无需重启redis服务。&lt;/p&gt;
&lt;h5 id=&quot;1-redis动态修改配置&quot;&gt;&lt;a href=&quot;#1-redis动态修改配置&quot; class=&quot;headerlink&quot; title=&quot;1. redis动态修改配置&quot;&gt;&lt;/a&gt;1. redis动态修改配置&lt;/h5&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# 列出所有支持动态配置的参数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;127.0.0.1:6379&amp;gt; config get *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  1) &amp;quot;dbfilename&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  2) &amp;quot;dump.rdb&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     ......&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     ......&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;213) &amp;quot;bind&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;214) &amp;quot;127.0.0.1&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="高级运维" scheme="https://garywu520.github.io/blog/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="redis" scheme="https://garywu520.github.io/blog/tags/redis/"/>
    
      <category term="CONFIG" scheme="https://garywu520.github.io/blog/tags/CONFIG/"/>
    
  </entry>
  
  <entry>
    <title>SFTP上传下载命令</title>
    <link href="https://garywu520.github.io/blog/2019/09/10/SFTP%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E5%91%BD%E4%BB%A4/"/>
    <id>https://garywu520.github.io/blog/2019/09/10/SFTP上传下载命令/</id>
    <published>2019-09-10T08:20:36.000Z</published>
    <updated>2019-09-10T08:34:55.169Z</updated>
    
    <content type="html"><![CDATA[<p>SFTP顾名思义，即它是基于SSH的上传与下载功能。它是lrzsz之外的另一选择。不需要服务器部署FTP服务</p><p>Mac端由于无法使用lrzsz，故SFTP是个不错的选择</p><a id="more"></a><h5 id="1-ssh配置文件"><a href="#1-ssh配置文件" class="headerlink" title="1. ssh配置文件"></a>1. ssh配置文件</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Port 22</span><br><span class="line">Protocol 2</span><br><span class="line">RSAAuthentication yes</span><br><span class="line">PubkeyAuthentication yes</span><br><span class="line">AuthorizedKeysFile  .ssh/authorized_keys</span><br><span class="line">PasswordAuthentication no</span><br><span class="line">PermitEmptyPasswords no</span><br><span class="line">UsePAM  yes</span><br><span class="line">PrintMotd no</span><br><span class="line">PrintLastLog no</span><br><span class="line">UseDNS no</span><br><span class="line">Subsystem   sftp  /usr/libexec/openssh/sftp-server </span><br><span class="line"></span><br><span class="line">ListenAddress 0.0.0.0:22</span><br><span class="line">ListenAddress xx.xx.xx.xx:22</span><br></pre></td></tr></table></figure><p>注：需要确保 sftp配置的/usr/libexec/openssh/sftp-server 文件是存在的，重启sshd服务</p><h5 id="2-Xshell连接SFTP"><a href="#2-Xshell连接SFTP" class="headerlink" title="2.  Xshell连接SFTP"></a>2.  Xshell连接SFTP</h5><p>​    连接需要指定密钥</p><h5 id="3-上传与下载"><a href="#3-上传与下载" class="headerlink" title="3. 上传与下载"></a>3. 上传与下载</h5><ul><li><p>单个文件下载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> get remote-file [<span class="built_in">local</span>-file]</span></span><br></pre></td></tr></table></figure></li><li><p>单个文件上传</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> put </span></span><br><span class="line">打开本地目录选择文件后上传</span><br></pre></td></tr></table></figure></li><li><p>中断连接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">bye</span></span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SFTP顾名思义，即它是基于SSH的上传与下载功能。它是lrzsz之外的另一选择。不需要服务器部署FTP服务&lt;/p&gt;
&lt;p&gt;Mac端由于无法使用lrzsz，故SFTP是个不错的选择&lt;/p&gt;
    
    </summary>
    
    
      <category term="高级运维" scheme="https://garywu520.github.io/blog/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="sftp" scheme="https://garywu520.github.io/blog/tags/sftp/"/>
    
      <category term="lrzsz" scheme="https://garywu520.github.io/blog/tags/lrzsz/"/>
    
      <category term="mac" scheme="https://garywu520.github.io/blog/tags/mac/"/>
    
      <category term="上传下载" scheme="https://garywu520.github.io/blog/tags/%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>xshell ssh连接错误10053</title>
    <link href="https://garywu520.github.io/blog/2019/08/29/xshell-ssh%E8%BF%9E%E6%8E%A5%E9%94%99%E8%AF%AF10053/"/>
    <id>https://garywu520.github.io/blog/2019/08/29/xshell-ssh连接错误10053/</id>
    <published>2019-08-29T12:40:46.000Z</published>
    <updated>2019-08-29T12:43:09.176Z</updated>
    
    <content type="html"><![CDATA[<h5 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Socket error Event: 32 Error: 10053.</span><br><span class="line">Connection closing...Socket close</span><br></pre></td></tr></table></figure><h5 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 很有可能有人恶意将系统根目录或部分核心目录修改了777权限,导致服务器登录异常</span></span><br><span class="line">history |grep 777</span><br></pre></td></tr></table></figure><a id="more"></a><h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5><p>恢复SSH登录相关文件权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chmod 400 /etc/ssh/*</span><br><span class="line">chmod 640  /etc/ssh/*.pub</span><br><span class="line">chown 600  /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart sshd</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;Error&quot;&gt;&lt;a href=&quot;#Error&quot; class=&quot;headerlink&quot; title=&quot;Error&quot;&gt;&lt;/a&gt;Error&lt;/h5&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Socket error Event: 32 Error: 10053.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Connection closing...Socket close&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h5 id=&quot;原因&quot;&gt;&lt;a href=&quot;#原因&quot; class=&quot;headerlink&quot; title=&quot;原因&quot;&gt;&lt;/a&gt;原因&lt;/h5&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; 很有可能有人恶意将系统根目录或部分核心目录修改了777权限,导致服务器登录异常&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;history |grep 777&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="高级运维" scheme="https://garywu520.github.io/blog/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="ssh" scheme="https://garywu520.github.io/blog/tags/ssh/"/>
    
      <category term="xshell" scheme="https://garywu520.github.io/blog/tags/xshell/"/>
    
      <category term="10053" scheme="https://garywu520.github.io/blog/tags/10053/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 301重定向到HTTPS的问题</title>
    <link href="https://garywu520.github.io/blog/2019/08/23/Nginx-301%E9%87%8D%E5%AE%9A%E5%90%91%E5%88%B0HTTPS%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://garywu520.github.io/blog/2019/08/23/Nginx-301重定向到HTTPS的问题/</id>
    <published>2019-08-23T08:14:30.000Z</published>
    <updated>2019-08-23T08:38:22.294Z</updated>
    
    <content type="html"><![CDATA[<p>Nginx强制配置301永久跳转后，APP发起POST请求会出现405错误，这是因为301跳转的操作让浏览器把POST请求变成了GET请求。</p><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><ul><li>301跳转示例：</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">return</span> <span class="number">301</span> https://www.xxx.com<span class="variable">$request_uri</span>;</span><br></pre></td></tr></table></figure><ul><li>解决办法：</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">return</span> <span class="number">307</span> https://www.xxx.com<span class="variable">$request_uri</span>;</span><br><span class="line">或</span><br><span class="line"><span class="attribute">return</span> <span class="number">308</span> https://www.xxx.com<span class="variable">$request_uri</span>;</span><br></pre></td></tr></table></figure><a id="more"></a><h5 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h5><ul><li><p>301 Moved Permanently</p><p>被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一</p></li><li><p>307  Temporary Redirect</p><p>请求的资源现在临时从不同的URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求</p></li><li><p>308 永久重定向</p><p>308状态代码[永久重定向],类似于301(永久移动)，但不允许将请求方法从POST更改为GET.</p></li></ul><h5 id="301和308的区别"><a href="#301和308的区别" class="headerlink" title="301和308的区别"></a>301和308的区别</h5><p>在 HTTP 协议中， 308 Permanent Redirect（永久重定向）是表示重定向的响应状态码，说明请求的资源已经被永久的移动到了由 Location 首部指定的 URL 上。在重定向过程中，请求方法和消息主体不会发生改变!</p><p>然而在 301 状态码的情况下，请求方法有时候会被客户端错误地修改为 GET 方法</p><p>参考：<a href="https://blog.imdst.com/nginxqiang-zhi-tiao-zhuan-https-jie-kou-de-postqing-qiu-bian-cheng-get/" target="_blank" rel="noopener">Linux运维笔记</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Nginx强制配置301永久跳转后，APP发起POST请求会出现405错误，这是因为301跳转的操作让浏览器把POST请求变成了GET请求。&lt;/p&gt;
&lt;h5 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;301跳转示例：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight nginx&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;301&lt;/span&gt; https://www.xxx.com&lt;span class=&quot;variable&quot;&gt;$request_uri&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;解决办法：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight nginx&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;307&lt;/span&gt; https://www.xxx.com&lt;span class=&quot;variable&quot;&gt;$request_uri&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;或&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;308&lt;/span&gt; https://www.xxx.com&lt;span class=&quot;variable&quot;&gt;$request_uri&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="高级运维" scheme="https://garywu520.github.io/blog/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="301" scheme="https://garywu520.github.io/blog/tags/301/"/>
    
      <category term="Nginx" scheme="https://garywu520.github.io/blog/tags/Nginx/"/>
    
      <category term="GET" scheme="https://garywu520.github.io/blog/tags/GET/"/>
    
      <category term="POST" scheme="https://garywu520.github.io/blog/tags/POST/"/>
    
      <category term="307" scheme="https://garywu520.github.io/blog/tags/307/"/>
    
      <category term="HTTPS" scheme="https://garywu520.github.io/blog/tags/HTTPS/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat 内存优化配置</title>
    <link href="https://garywu520.github.io/blog/2019/08/22/Tomcat-%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%E9%85%8D%E7%BD%AE/"/>
    <id>https://garywu520.github.io/blog/2019/08/22/Tomcat-内存优化配置/</id>
    <published>2019-08-22T05:35:22.000Z</published>
    <updated>2019-08-22T05:38:51.159Z</updated>
    
    <content type="html"><![CDATA[<p>以Tomcat 8.x为例，来说明内存优化配置</p><h5 id="一、修改配置如下"><a href="#一、修改配置如下" class="headerlink" title="一、修改配置如下"></a>一、修改配置如下</h5><p>修改 {tomcat_dir}/bin/catalina.sh ，搜索“Execute” 行，在下面加入如下行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ----- Execute The Requested Command -----------------------------------------</span></span><br><span class="line">JAVA_OPTS="$JAVA_OPTS -server -Xms256m -Xmx512m"</span><br></pre></td></tr></table></figure><p>参数：</p><p>-Xms256m：初始化堆内存大小（注意，不加M的话单位是KB）<br>-Xmx512m：最大堆内存大小<br> -XX:PermSize=128M：初始化类加载内存池大小 </p><p>注：以下两个参数在Tomcat8中，启动会报错</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:MaxPermSize=256M：最大类加载内存池大小 </span><br><span class="line">-XX:MaxNewSize=256M：设置JAVA堆区域新生代内存的最大可分配大小</span><br></pre></td></tr></table></figure><a id="more"></a><h5 id="二、确认进程已经杀死"><a href="#二、确认进程已经杀死" class="headerlink" title="二、确认进程已经杀死"></a>二、确认进程已经杀死</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bin/shutdown.sh</span><br><span class="line">通过ps命令查看此tomcat进程是否依然存在，如果存在则使用kill命令</span><br></pre></td></tr></table></figure><h5 id="三、启动Tomcat服务"><a href="#三、启动Tomcat服务" class="headerlink" title="三、启动Tomcat服务"></a>三、启动Tomcat服务</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bin/startup.sh</span><br><span class="line">netstat -lntup|grep 8081</span><br><span class="line">tail -f log/catalina.out</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以Tomcat 8.x为例，来说明内存优化配置&lt;/p&gt;
&lt;h5 id=&quot;一、修改配置如下&quot;&gt;&lt;a href=&quot;#一、修改配置如下&quot; class=&quot;headerlink&quot; title=&quot;一、修改配置如下&quot;&gt;&lt;/a&gt;一、修改配置如下&lt;/h5&gt;&lt;p&gt;修改 {tomcat_dir}/bin/catalina.sh ，搜索“Execute” 行，在下面加入如下行：&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; ----- Execute The Requested Command -----------------------------------------&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;JAVA_OPTS=&quot;$JAVA_OPTS -server -Xms256m -Xmx512m&quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;参数：&lt;/p&gt;
&lt;p&gt;-Xms256m：初始化堆内存大小（注意，不加M的话单位是KB）&lt;br&gt;-Xmx512m：最大堆内存大小&lt;br&gt; -XX:PermSize=128M：初始化类加载内存池大小 &lt;/p&gt;
&lt;p&gt;注：以下两个参数在Tomcat8中，启动会报错&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-XX:MaxPermSize=256M：最大类加载内存池大小 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-XX:MaxNewSize=256M：设置JAVA堆区域新生代内存的最大可分配大小&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="tomcat" scheme="https://garywu520.github.io/blog/tags/tomcat/"/>
    
      <category term="jvm" scheme="https://garywu520.github.io/blog/tags/jvm/"/>
    
      <category term="jps" scheme="https://garywu520.github.io/blog/tags/jps/"/>
    
      <category term="内存" scheme="https://garywu520.github.io/blog/tags/%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>nginx快速部署文件下载服务</title>
    <link href="https://garywu520.github.io/blog/2019/08/21/nginx%E5%BF%AB%E9%80%9F%E9%83%A8%E7%BD%B2%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%9C%8D%E5%8A%A1/"/>
    <id>https://garywu520.github.io/blog/2019/08/21/nginx快速部署文件下载服务/</id>
    <published>2019-08-21T10:14:08.000Z</published>
    <updated>2019-08-21T10:47:10.184Z</updated>
    
    <content type="html"><![CDATA[<h5 id="让nginx直接下载文件的方法"><a href="#让nginx直接下载文件的方法" class="headerlink" title="让nginx直接下载文件的方法"></a>让nginx直接下载文件的方法</h5><p>在nginx.conf下增加配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        access_log logs/access.download.com.log main;</span><br><span class="line">        error_log logs/error.download.com.log;</span><br><span class="line">        server_name download.com;</span><br><span class="line"></span><br><span class="line">        root /data/android;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">新增配置区域</span></span><br><span class="line">        location /app &#123;</span><br><span class="line">                default_type application/octet-stream;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将下载的文件放在/data/android/app目录下,  reload Nginx，之后就可以通过download.com访问了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;让nginx直接下载文件的方法&quot;&gt;&lt;a href=&quot;#让nginx直接下载文件的方法&quot; class=&quot;headerlink&quot; title=&quot;让nginx直接下载文件的方法&quot;&gt;&lt;/a&gt;让nginx直接下载文件的方法&lt;/h5&gt;&lt;p&gt;在nginx.conf下增加配置&lt;/
      
    
    </summary>
    
    
      <category term="nginx" scheme="https://garywu520.github.io/blog/tags/nginx/"/>
    
      <category term="nginx下载" scheme="https://garywu520.github.io/blog/tags/nginx%E4%B8%8B%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>shell脚本监控TraceRoute</title>
    <link href="https://garywu520.github.io/blog/2019/08/15/shell%E8%84%9A%E6%9C%AC%E7%9B%91%E6%8E%A7TraceRoute/"/>
    <id>https://garywu520.github.io/blog/2019/08/15/shell脚本监控TraceRoute/</id>
    <published>2019-08-15T06:28:32.000Z</published>
    <updated>2019-08-15T06:53:21.463Z</updated>
    
    <content type="html"><![CDATA[<h5 id="shell脚本逻辑："><a href="#shell脚本逻辑：" class="headerlink" title="shell脚本逻辑："></a>shell脚本逻辑：</h5><ul><li>不能以 trace命令返回值作为成功或失败的依据，不可达的地址返回值也是0</li><li>取文本的最后一跳信息，当最后一跳包含$IP，则视为Trace正常。若$IP的检索结果等于0，则视为Trace失败。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">!/bin/env bash</span><br><span class="line">IP=xx.xx.xx.xx</span><br><span class="line">FILE=/tmp/besttrace.txt</span><br><span class="line">EMAIL=xxx@xx.com</span><br><span class="line"></span><br><span class="line">/sbin/besttrace -q 1 $IP &gt;$FILE</span><br><span class="line">NUM=`grep "$IP" $FILE|awk NR==2|wc -l`</span><br><span class="line">if [ $NUM -lt 1 ];then</span><br><span class="line">   INFO=`cat $FILE`</span><br><span class="line"><span class="meta">   #</span><span class="bash">发送告警邮件 </span></span><br><span class="line">   echo -e "邮件发自$HOSTNAME\n详情如下:\n\n$INFO"|mail -s "TraceRoute告警" $EMAIL</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;shell脚本逻辑：&quot;&gt;&lt;a href=&quot;#shell脚本逻辑：&quot; class=&quot;headerlink&quot; title=&quot;shell脚本逻辑：&quot;&gt;&lt;/a&gt;shell脚本逻辑：&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;不能以 trace命令返回值作为成功或失败的依据，不可达的地址返
      
    
    </summary>
    
    
      <category term="高级运维" scheme="https://garywu520.github.io/blog/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="shell" scheme="https://garywu520.github.io/blog/tags/shell/"/>
    
      <category term="MTR" scheme="https://garywu520.github.io/blog/tags/MTR/"/>
    
      <category term="traceroute" scheme="https://garywu520.github.io/blog/tags/traceroute/"/>
    
      <category term="besttrace" scheme="https://garywu520.github.io/blog/tags/besttrace/"/>
    
  </entry>
  
  <entry>
    <title>zabbix报警邮件内容带附件-解决方法</title>
    <link href="https://garywu520.github.io/blog/2019/08/15/zabbix%E6%8A%A5%E8%AD%A6%E9%82%AE%E4%BB%B6%E5%86%85%E5%AE%B9%E5%B8%A6%E9%99%84%E4%BB%B6-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>https://garywu520.github.io/blog/2019/08/15/zabbix报警邮件内容带附件-解决方法/</id>
    <published>2019-08-15T02:32:47.000Z</published>
    <updated>2019-08-15T02:44:46.898Z</updated>
    
    <content type="html"><![CDATA[<p>zabbix设置邮件脚本报警的后，测试发现，邮件正文内容变成了tcmime.1278.1278.1724.bin 或 ATT00001.bin</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><h5 id="1-安装dos2unix"><a href="#1-安装dos2unix" class="headerlink" title="1. 安装dos2unix"></a>1. 安装dos2unix</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">wget http://mirror.centos.org/centos/7/os/x86_64/Packages/dos2unix-6.0.3-7.el7.x86_64.rpm</span><br><span class="line">rpm -Uvh dos2unix-6.0.3-7.el7.x86_64.rpm</span><br></pre></td></tr></table></figure><a id="more"></a><h5 id="2-修改sendmail-sh"><a href="#2-修改sendmail-sh" class="headerlink" title="2. 修改sendmail.sh"></a>2. 修改sendmail.sh</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/lib/zabbix/alertscripts/</span><br></pre></td></tr></table></figure><p>vim sendmail.sh</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">export.UTF-8      //解决发送的中文变成了乱码的问题</span></span><br><span class="line">FILE=/tmp/mailtmp.txt </span><br><span class="line">echo "$3" &gt;$FILE</span><br><span class="line">/bin/dos2unix -k $FILE   //解决了发送的邮件内容变成附件的问题。</span><br><span class="line">/bin/mail -s "$2" $1 &lt; $FILE</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">touch /tmp/mailtmp.txt</span><br><span class="line">chown zabbix.zabbix /tmp/mailtmp.txt</span><br><span class="line">ls -lh /tmp/mailtmp.txt</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;zabbix设置邮件脚本报警的后，测试发现，邮件正文内容变成了tcmime.1278.1278.1724.bin 或 ATT00001.bin&lt;/p&gt;
&lt;h4 id=&quot;解决方案&quot;&gt;&lt;a href=&quot;#解决方案&quot; class=&quot;headerlink&quot; title=&quot;解决方案&quot;&gt;&lt;/a&gt;解决方案&lt;/h4&gt;&lt;h5 id=&quot;1-安装dos2unix&quot;&gt;&lt;a href=&quot;#1-安装dos2unix&quot; class=&quot;headerlink&quot; title=&quot;1. 安装dos2unix&quot;&gt;&lt;/a&gt;1. 安装dos2unix&lt;/h5&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;wget http://mirror.centos.org/centos/7/os/x86_64/Packages/dos2unix-6.0.3-7.el7.x86_64.rpm&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;rpm -Uvh dos2unix-6.0.3-7.el7.x86_64.rpm&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="高级运维" scheme="https://garywu520.github.io/blog/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="zabbix" scheme="https://garywu520.github.io/blog/tags/zabbix/"/>
    
      <category term="报警" scheme="https://garywu520.github.io/blog/tags/%E6%8A%A5%E8%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>supervisor部署</title>
    <link href="https://garywu520.github.io/blog/2019/08/12/supervisor%E9%83%A8%E7%BD%B2/"/>
    <id>https://garywu520.github.io/blog/2019/08/12/supervisor部署/</id>
    <published>2019-08-12T06:17:53.000Z</published>
    <updated>2019-08-12T07:18:00.461Z</updated>
    
    <content type="html"><![CDATA[<h5 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h5><ul><li>CentOS7</li></ul><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install -y epel-release</span><br><span class="line">yum install -y supervisor</span><br><span class="line">systemctl enable supervisord</span><br></pre></td></tr></table></figure><p>cat /etc/supervisord.conf  </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="regexp">/etc/</span>supervisord.conf     <span class="comment">#清空默认模板文件，将下面的内容贴到本文件</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>cat  /etc/supervisord.conf</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[unix_http_server]</span><br><span class="line">file=/var/run/supervisor.sock   ; (the path to the socket file)</span><br><span class="line"></span><br><span class="line">[supervisord]</span><br><span class="line">logfile=/var/log/supervisord.log ; (main log file;default $CWD/supervisord.log)</span><br><span class="line">logfile_maxbytes=50MB        ; (max main logfile bytes b4 rotation;default 50MB)</span><br><span class="line">logfile_backups=10           ; (num of main logfile rotation backups;default 10)</span><br><span class="line">loglevel=info                ; (log level;default info; others: debug,warn,trace)</span><br><span class="line">pidfile=/var/run/supervisord.pid ; (supervisord pidfile;default supervisord.pid)</span><br><span class="line">nodaemon=false               ; (start in foreground if true;default false)</span><br><span class="line">minfds=1024                  ; (min. avail startup file descriptors;default 1024)</span><br><span class="line">minprocs=200                 ; (min. avail process descriptors;default 200)</span><br><span class="line"></span><br><span class="line">[rpcinterface:supervisor]</span><br><span class="line">supervisor.rpcinterface_factory = supervisor.rpcinterface:make_main_rpcinterface</span><br><span class="line"></span><br><span class="line">[supervisorctl]</span><br><span class="line">serverurl=unix:///var/run/supervisor.sock ; use a unix:// URL  for a unix socket</span><br><span class="line"></span><br><span class="line">[include]</span><br><span class="line">files = /etc/supervisord.d/*.conf</span><br><span class="line"></span><br><span class="line">; environment=JAVA_HOME="/usr/local/jdk",JRE_HOME="/usr/local/jdk/jre"</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start supervisord</span><br><span class="line">systemctl startus supervisord</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;CentOS7&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h5&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;yum install -y epel-release&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;yum install -y supervisor&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;systemctl enable supervisord&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;cat /etc/supervisord.conf  &lt;/p&gt;
&lt;figure class=&quot;highlight awk&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt; &lt;span class=&quot;regexp&quot;&gt;/etc/&lt;/span&gt;supervisord.conf     &lt;span class=&quot;comment&quot;&gt;#清空默认模板文件，将下面的内容贴到本文件&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="高级运维" scheme="https://garywu520.github.io/blog/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="supervisor" scheme="https://garywu520.github.io/blog/tags/supervisor/"/>
    
      <category term="supervisorctl" scheme="https://garywu520.github.io/blog/tags/supervisorctl/"/>
    
      <category term="supervisord" scheme="https://garywu520.github.io/blog/tags/supervisord/"/>
    
  </entry>
  
  <entry>
    <title>把运行的容器打包成Docker镜像</title>
    <link href="https://garywu520.github.io/blog/2019/08/08/%E6%8A%8A%E8%BF%90%E8%A1%8C%E7%9A%84%E5%AE%B9%E5%99%A8%E6%89%93%E5%8C%85%E6%88%90Docker%E9%95%9C%E5%83%8F/"/>
    <id>https://garywu520.github.io/blog/2019/08/08/把运行的容器打包成Docker镜像/</id>
    <published>2019-08-08T08:42:19.000Z</published>
    <updated>2019-08-08T08:53:01.254Z</updated>
    
    <content type="html"><![CDATA[<p>根据基础镜像，运行的容器。有时候需要对内部环境做些调整，调整后想把当前环境打包成新的Image镜像</p><p>方法如下</p><a id="more"></a><h5 id="使用docker-commit命令"><a href="#使用docker-commit命令" class="headerlink" title="使用docker commit命令"></a>使用docker commit命令</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker commit --<span class="built_in">help</span></span></span><br><span class="line">  -a, --author string    指定一个作者,如：GaryWu</span><br><span class="line">  -c, --change list      将Dockerfile指令应用于创建的映像</span><br><span class="line">  -m, --message string   字符串消息</span><br><span class="line">  -p, --pause            在提交期间暂停容器（默认为true）</span><br></pre></td></tr></table></figure><h5 id="用法-示例"><a href="#用法-示例" class="headerlink" title="用法-示例"></a>用法-示例</h5><ul><li>获取容器ID</li></ul><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">首先通过docker ps -<span class="keyword">a</span>获取想要打包的容器ID</span><br></pre></td></tr></table></figure><ul><li>打包镜像</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 格式：</span></span><br><span class="line">docker commit -a "&lt;作者&gt;" -m "&lt;字符串消息&gt;"  &lt;容器ID&gt;  &lt;新镜像名&gt;:&lt;版本号&gt;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker commit -a <span class="string">"GaryWu"</span> -m <span class="string">"v1"</span> bef669f03c61 centos:v1</span></span><br><span class="line">sha256:8ae09cd2fbde04dcfa313566c05052f75ebbd40f375b3d747169e00a5ea7ca73</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看镜像</span></span><br><span class="line">[root@iZ2zeb1y67msd8vbu7ln6tZ ~]# docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">centos              v1                  8ae09cd2fbde        21 seconds ago      3.59GB</span><br><span class="line">centos              latest              9f38484d220f        4 months ago        202MB</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;根据基础镜像，运行的容器。有时候需要对内部环境做些调整，调整后想把当前环境打包成新的Image镜像&lt;/p&gt;
&lt;p&gt;方法如下&lt;/p&gt;
    
    </summary>
    
    
      <category term="高级运维" scheme="https://garywu520.github.io/blog/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="docker" scheme="https://garywu520.github.io/blog/tags/docker/"/>
    
      <category term="images" scheme="https://garywu520.github.io/blog/tags/images/"/>
    
      <category term="镜像打包" scheme="https://garywu520.github.io/blog/tags/%E9%95%9C%E5%83%8F%E6%89%93%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>supervisor管理二进制程序</title>
    <link href="https://garywu520.github.io/blog/2019/08/08/supervisor%E7%AE%A1%E7%90%86%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%A8%8B%E5%BA%8F/"/>
    <id>https://garywu520.github.io/blog/2019/08/08/supervisor管理二进制程序/</id>
    <published>2019-08-08T06:57:10.000Z</published>
    <updated>2019-08-08T07:00:56.087Z</updated>
    
    <content type="html"><![CDATA[<p>有时候需要使用supervisor管理二进制程序，区别是需要进入到相关目录才能运行，这时候就需要directory来指定工作目录了。</p><p>cat  /etc/supervisor.conf</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[program:app1]</span><br><span class="line">directory=/usr/local/auto/app1</span><br><span class="line">command=/usr/local/auto/app1/Server</span><br><span class="line">stdout_logfile=/usr/local/auto/app1/app1.log</span><br><span class="line">autostart=true</span><br><span class="line">autorestart=true</span><br><span class="line">startsecs=5</span><br><span class="line">priority=1</span><br><span class="line">stopasgroup=true</span><br><span class="line">killasgroup=true</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有时候需要使用supervisor管理二进制程序，区别是需要进入到相关目录才能运行，这时候就需要directory来指定工作目录了。&lt;/p&gt;
&lt;p&gt;cat  /etc/supervisor.conf&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="高级运维" scheme="https://garywu520.github.io/blog/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="supervisor" scheme="https://garywu520.github.io/blog/tags/supervisor/"/>
    
      <category term="二进制" scheme="https://garywu520.github.io/blog/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>docker导出导入镜像</title>
    <link href="https://garywu520.github.io/blog/2019/08/08/docker%E5%AF%BC%E5%87%BA%E5%AF%BC%E5%85%A5%E9%95%9C%E5%83%8F/"/>
    <id>https://garywu520.github.io/blog/2019/08/08/docker导出导入镜像/</id>
    <published>2019-08-08T03:25:02.000Z</published>
    <updated>2019-08-08T03:31:27.087Z</updated>
    
    <content type="html"><![CDATA[<p>当基于基础镜像，配置并优化了相关环境后，重新打包制作的Docker镜像需要导出保存时，就需要导出导入操作了。</p><h5 id="导出镜像"><a href="#导出镜像" class="headerlink" title="导出镜像"></a>导出镜像</h5><p>如果要导出镜像到本地文件，可以使用docker save命令. 假设要导出的新镜像名为centos_v1</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br><span class="line">docker save -o centos_v1.tar centos_v1</span><br></pre></td></tr></table></figure><h5 id="载入镜像"><a href="#载入镜像" class="headerlink" title="载入镜像"></a>载入镜像</h5><p>可以使用docker load从导出的本地文件中再导入到本地镜像库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker load --input centos_v1.tar</span><br><span class="line">或</span><br><span class="line">docker load &lt; centos_v1.tar</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当基于基础镜像，配置并优化了相关环境后，重新打包制作的Docker镜像需要导出保存时，就需要导出导入操作了。&lt;/p&gt;
&lt;h5 id=&quot;导出镜像&quot;&gt;&lt;a href=&quot;#导出镜像&quot; class=&quot;headerlink&quot; title=&quot;导出镜像&quot;&gt;&lt;/a&gt;导出镜像&lt;/h5&gt;&lt;p&gt;
      
    
    </summary>
    
    
      <category term="高级运维" scheme="https://garywu520.github.io/blog/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="docker" scheme="https://garywu520.github.io/blog/tags/docker/"/>
    
      <category term="images" scheme="https://garywu520.github.io/blog/tags/images/"/>
    
      <category term="导入导出" scheme="https://garywu520.github.io/blog/tags/%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/"/>
    
  </entry>
  
  <entry>
    <title>docker exec命令</title>
    <link href="https://garywu520.github.io/blog/2019/08/07/docker-exec%E5%91%BD%E4%BB%A4/"/>
    <id>https://garywu520.github.io/blog/2019/08/07/docker-exec命令/</id>
    <published>2019-08-07T12:32:21.000Z</published>
    <updated>2019-08-07T12:42:15.343Z</updated>
    
    <content type="html"><![CDATA[<p>docker exec ：在运行的容器中执行命令</p><h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><p>OPTIONS说明:</p><ul><li>-d: 分离模式：在后台运行</li><li>-i : 即使没有附加也保持STDIN打开</li><li>-t: 分配一个伪终端</li></ul><a id="more"></a><h5 id="示例1：在运行的容器中以交互模式运行容器内-root-runoob-sh脚本"><a href="#示例1：在运行的容器中以交互模式运行容器内-root-runoob-sh脚本" class="headerlink" title="示例1：在运行的容器中以交互模式运行容器内 /root/runoob.sh脚本"></a>示例1：在运行的容器中以交互模式运行容器内 /root/runoob.sh脚本</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">runoob@runoob:~$ docker exec -it mydev /bin/sh /root/runoob.sh</span><br><span class="line">http://www.runoob.com/</span><br></pre></td></tr></table></figure><h5 id="示例2：在运行的容器中开启一个交互模式的终端"><a href="#示例2：在运行的容器中开启一个交互模式的终端" class="headerlink" title="示例2：在运行的容器中开启一个交互模式的终端"></a>示例2：在运行的容器中开启一个交互模式的终端</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">runoob@runoob:~$ docker exec -i -t  mydev /bin/bash</span><br><span class="line">root@b1a0703e41e7:/#</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;docker exec ：在运行的容器中执行命令&lt;/p&gt;
&lt;h5 id=&quot;语法&quot;&gt;&lt;a href=&quot;#语法&quot; class=&quot;headerlink&quot; title=&quot;语法&quot;&gt;&lt;/a&gt;语法&lt;/h5&gt;&lt;p&gt;OPTIONS说明:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;-d: 分离模式：在后台运行&lt;/li&gt;
&lt;li&gt;-i : 即使没有附加也保持STDIN打开&lt;/li&gt;
&lt;li&gt;-t: 分配一个伪终端&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="高级运维" scheme="https://garywu520.github.io/blog/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="docker" scheme="https://garywu520.github.io/blog/tags/docker/"/>
    
      <category term="exec命令" scheme="https://garywu520.github.io/blog/tags/exec%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>使用supervisor管理Tomcat进程</title>
    <link href="https://garywu520.github.io/blog/2019/08/07/%E4%BD%BF%E7%94%A8supervisor%E7%AE%A1%E7%90%86Tomcat%E8%BF%9B%E7%A8%8B/"/>
    <id>https://garywu520.github.io/blog/2019/08/07/使用supervisor管理Tomcat进程/</id>
    <published>2019-08-07T10:10:23.000Z</published>
    <updated>2019-08-07T13:12:32.714Z</updated>
    
    <content type="html"><![CDATA[<p>使用 supervisord 监控管理的进程必须以 nodaemon 启动，而 tomcat 的 startup.sh 脚本是daemon方式的，现在不能用startup.sh形式，所以要用catalina.sh，且在后面加 run。</p><a id="more"></a><h5 id="supervisor-tomcat启动配置文件"><a href="#supervisor-tomcat启动配置文件" class="headerlink" title="supervisor tomcat启动配置文件"></a>supervisor tomcat启动配置文件</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[program:tomcat_8081]</span><br><span class="line">command=/usr/local/tomcat_8081/bin/catalina.sh run</span><br><span class="line">stdout_logfile=/usr/local/tomcat_8081/logs/catalina.out</span><br><span class="line">environment=JAVA_HOME="/usr/local/jdk",JRE_HOME="/usr/local/jdk/jre"</span><br><span class="line">autostart=true</span><br><span class="line">autorestart=true</span><br><span class="line">startsecs=5</span><br><span class="line">priority=1</span><br><span class="line">stopasgroup=true</span><br><span class="line">killasgroup=true</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">supervisorctl reread</span><br><span class="line">supervisorctl add tomcat_8081</span><br><span class="line">supervisorctl restart tomcat_8081</span><br><span class="line">supervisorctl status</span><br><span class="line"></span><br><span class="line">移除配置</span><br><span class="line">(1)删除配置文件</span><br><span class="line">(2)supervisorctl reread   重新读取配置文件</span><br><span class="line">(3)supervisorctl update   更新配置</span><br></pre></td></tr></table></figure><h5 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h5><p>upervisor启动Tomcat等JAVA程序，log报错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Neither the JAVA_HOME nor the JRE_HOME environment variable is defined</span><br><span class="line">At least one of these environment variable is needed to run this program</span><br></pre></td></tr></table></figure><p>解决方法：</p><p>方式一：如果是在docker容器内运行的supervisor和tomcat, 请将JAVA环境变量从/etc/profile 剪切到 ~/.bashrc目录，并source  ~/.bashrc</p><p>方式二：在/etc/supervisord.conf文件末尾，添加如下行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">environment=JAVA_HOME="/usr/local/jdk",JRE_HOME="/usr/local/jdk/jre"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">注：多个环境变量使用英文逗号隔开</span></span><br></pre></td></tr></table></figure><p>重启supervisor服务后，再使用supervisor重启tomcat即可</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用 supervisord 监控管理的进程必须以 nodaemon 启动，而 tomcat 的 startup.sh 脚本是daemon方式的，现在不能用startup.sh形式，所以要用catalina.sh，且在后面加 run。&lt;/p&gt;
    
    </summary>
    
    
      <category term="高级运维" scheme="https://garywu520.github.io/blog/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="tomcat" scheme="https://garywu520.github.io/blog/tags/tomcat/"/>
    
      <category term="supervisor" scheme="https://garywu520.github.io/blog/tags/supervisor/"/>
    
  </entry>
  
  <entry>
    <title>Docker容器使用systemctl报错</title>
    <link href="https://garywu520.github.io/blog/2019/08/07/Docker%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8systemctl%E6%8A%A5%E9%94%99/"/>
    <id>https://garywu520.github.io/blog/2019/08/07/Docker容器使用systemctl报错/</id>
    <published>2019-08-07T08:56:42.000Z</published>
    <updated>2019-08-07T09:01:59.169Z</updated>
    
    <content type="html"><![CDATA[<h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h5><p>docker运行CentOS7容器，使用systemctl命令启动服务报错，错误如下：</p><p>Failed to get D-Bus connection: Operation not permitted</p><a id="more"></a><h5 id="原理解释"><a href="#原理解释" class="headerlink" title="原理解释"></a>原理解释</h5><p>Docker的设计理念是在容器里面不运行后台服务，容器本身就是宿主机上的一个独立的主进程，也可以间接的理解为就是容器里运行服务的应用进程。一个容器的生命周期是围绕这个主进程存在的，所以正确的使用容器方法是将里面的服务运行在前台。</p><p>再说到systemd，这个套件已经成为主流Linux发行版（比如CentOS7、Ubuntu14+）默认的服务管理，取代了传统的SystemV风格服务管理。systemd维护系统服务程序，它需要特权去会访问Linux内核。而容器并不是一个完整的操作系统，只有一个文件系统，而且默认启动只是普通用户这样的权限访问Linux内核，也就是没有特权，所以自然就用不了！</p><p>因此，请遵守容器设计原则，一个容器里运行一个前台服务！</p><h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><p>我就想这样运行，难道解决不了吗？</p><p>答：可以，以特权模式运行容器。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">创建容器</span></span><br><span class="line">docker run  --privileged=true -v /tmp/soft:/tmp/soft --name mydev -d centos /usr/sbin/init</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">进入容器</span></span><br><span class="line">docker exec -it mydev /bin/bash</span><br></pre></td></tr></table></figure><p>这样可以使用systemctl启动服务了</p><p>参考：<a href="https://blog.51cto.com/lizhenliang/1975466" target="_blank" rel="noopener">51CTO</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h5&gt;&lt;p&gt;docker运行CentOS7容器，使用systemctl命令启动服务报错，错误如下：&lt;/p&gt;
&lt;p&gt;Failed to get D-Bus connection: Operation not permitted&lt;/p&gt;
    
    </summary>
    
    
      <category term="高级运维" scheme="https://garywu520.github.io/blog/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="Docker" scheme="https://garywu520.github.io/blog/tags/Docker/"/>
    
      <category term="systemctl" scheme="https://garywu520.github.io/blog/tags/systemctl/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat多实例部署</title>
    <link href="https://garywu520.github.io/blog/2019/08/07/Tomcat%E5%A4%9A%E5%AE%9E%E4%BE%8B%E9%83%A8%E7%BD%B2/"/>
    <id>https://garywu520.github.io/blog/2019/08/07/Tomcat多实例部署/</id>
    <published>2019-08-07T06:09:32.000Z</published>
    <updated>2019-08-07T07:01:53.745Z</updated>
    
    <content type="html"><![CDATA[<h5 id="首先了解下Tomcat服务启动所需端口号"><a href="#首先了解下Tomcat服务启动所需端口号" class="headerlink" title="首先了解下Tomcat服务启动所需端口号"></a>首先了解下Tomcat服务启动所需端口号</h5><ul><li><strong>Server Port：</strong>该端口用于监听关闭tomcat的shutdown命令，默认端口:8005</li><li><strong>Connector Port:</strong>  该端口用于监听HTTP的请求，默认端口：8080</li><li><strong>AJP Port:</strong> 该端口用于监听AJP(Apache JServ Protocal)协议上的请求，通常用于整合HTTP服务器，默认端口: 8009【用不到可注释】</li><li><strong>Redirect Port:</strong> 重定向端口，出现在Connector配置中。默认端口：8443</li></ul><p>​       作用：当用户用http请求某个资源，而该资源本身又被设置了必须要https方式访问，此时Tomcat会自动重定向到这个redirectPort设置的https端口。</p><a id="more"></a><h5 id="1-Tomcat安装"><a href="#1-Tomcat安装" class="headerlink" title="1. Tomcat安装"></a>1. Tomcat安装</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf apache-tomcat-8.0.27.tar.gz </span><br><span class="line">cp -a apache-tomcat-8.0.27 tomcat8_1</span><br><span class="line">cp -a apache-tomcat-8.0.27 tomcat8_2</span><br></pre></td></tr></table></figure><h5 id="2-分别修改两个Tomcat实例的端口配置"><a href="#2-分别修改两个Tomcat实例的端口配置" class="headerlink" title="2. 分别修改两个Tomcat实例的端口配置"></a>2. 分别修改两个Tomcat实例的端口配置</h5><p>目的是：避免端口冲突。</p><ul><li>第1个实例端口-配置 – tomcat8_1/conf/server.xml<ul><li>Server Port: 8001 </li><li>Connector Port: 8081</li><li>AJP Port: 8011</li><li>Redirect Port: 8443</li></ul></li><li>第2个实例端口-配置 – tomcat8_2/conf/server.xml<ul><li>Server Port: 8002</li><li>Connector Port: 8082</li><li>AJP Port: 8012</li><li>Redirect Port: 9443</li></ul></li></ul><h5 id="3-分别优化Tomcat"><a href="#3-分别优化Tomcat" class="headerlink" title="3.  分别优化Tomcat"></a>3.  分别优化Tomcat</h5><p>​    略</p><h5 id="4-备份实例，便于日后分发"><a href="#4-备份实例，便于日后分发" class="headerlink" title="4. 备份实例，便于日后分发"></a>4. 备份实例，便于日后分发</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar zcf muti_tomcat.tar.gz ./tomcat8_1 ./tomcat8_2</span><br></pre></td></tr></table></figure><h5 id="5-启动多实例"><a href="#5-启动多实例" class="headerlink" title="5. 启动多实例"></a>5. 启动多实例</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/application/tomcat8_1/bin/startup.sh </span><br><span class="line">/application/tomcat8_2/bin/startup.sh</span><br></pre></td></tr></table></figure><h5 id="6-验证"><a href="#6-验证" class="headerlink" title="6. 验证"></a>6. 验证</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看端口和进程</span></span><br><span class="line">[root@zabbix-proxy ~]# netstat -lntup|grep java</span><br><span class="line">tcp6       0      0 127.0.0.1:8081       39534/java          </span><br><span class="line">tcp6       0      0 127.0.0.1:8082       39534/java</span><br><span class="line"></span><br><span class="line">[root@zabbix-proxy ~]# jps -m</span><br></pre></td></tr></table></figure><p>web访问</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://ip:8081</span><br><span class="line">http://ip:8082</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;首先了解下Tomcat服务启动所需端口号&quot;&gt;&lt;a href=&quot;#首先了解下Tomcat服务启动所需端口号&quot; class=&quot;headerlink&quot; title=&quot;首先了解下Tomcat服务启动所需端口号&quot;&gt;&lt;/a&gt;首先了解下Tomcat服务启动所需端口号&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Server Port：&lt;/strong&gt;该端口用于监听关闭tomcat的shutdown命令，默认端口:8005&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Connector Port:&lt;/strong&gt;  该端口用于监听HTTP的请求，默认端口：8080&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;AJP Port:&lt;/strong&gt; 该端口用于监听AJP(Apache JServ Protocal)协议上的请求，通常用于整合HTTP服务器，默认端口: 8009【用不到可注释】&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Redirect Port:&lt;/strong&gt; 重定向端口，出现在Connector配置中。默认端口：8443&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;​       作用：当用户用http请求某个资源，而该资源本身又被设置了必须要https方式访问，此时Tomcat会自动重定向到这个redirectPort设置的https端口。&lt;/p&gt;
    
    </summary>
    
    
      <category term="高级运维" scheme="https://garywu520.github.io/blog/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="tomcat" scheme="https://garywu520.github.io/blog/tags/tomcat/"/>
    
      <category term="tomcat8" scheme="https://garywu520.github.io/blog/tags/tomcat8/"/>
    
      <category term="tomcat多实例" scheme="https://garywu520.github.io/blog/tags/tomcat%E5%A4%9A%E5%AE%9E%E4%BE%8B/"/>
    
      <category term="jdk" scheme="https://garywu520.github.io/blog/tags/jdk/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat-将项目打包成war包</title>
    <link href="https://garywu520.github.io/blog/2019/08/07/Tomcat-%E5%B0%86%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E6%88%90war%E5%8C%85/"/>
    <id>https://garywu520.github.io/blog/2019/08/07/Tomcat-将项目打包成war包/</id>
    <published>2019-08-07T05:50:49.000Z</published>
    <updated>2019-08-07T06:05:47.249Z</updated>
    
    <content type="html"><![CDATA[<p>要求：提前安装jdk</p><h5 id="1-打包"><a href="#1-打包" class="headerlink" title="1. 打包"></a>1. 打包</h5><p>将当前目录下的所有文件打包成project.war</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jar -cvfM0 project.war ./</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>-c 创建war包</li><li>-v 显示打包过程</li><li>-f  指定JAR文件名</li><li>-M  不产生所有项的清单（MANIFEST〕文件，此参数会忽略 -m 参数</li><li>-0    这个是阿拉伯数字，只打包不压缩的意思</li></ul><h5 id="2-解压"><a href="#2-解压" class="headerlink" title="2. 解压"></a>2. 解压</h5><p>解压到当前目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jar -xvf project.war</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;要求：提前安装jdk&lt;/p&gt;
&lt;h5 id=&quot;1-打包&quot;&gt;&lt;a href=&quot;#1-打包&quot; class=&quot;headerlink&quot; title=&quot;1. 打包&quot;&gt;&lt;/a&gt;1. 打包&lt;/h5&gt;&lt;p&gt;将当前目录下的所有文件打包成project.war&lt;/p&gt;
&lt;figure clas
      
    
    </summary>
    
    
      <category term="高级运维" scheme="https://garywu520.github.io/blog/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="tomcat" scheme="https://garywu520.github.io/blog/tags/tomcat/"/>
    
      <category term="jar" scheme="https://garywu520.github.io/blog/tags/jar/"/>
    
      <category term="war" scheme="https://garywu520.github.io/blog/tags/war/"/>
    
  </entry>
  
</feed>
